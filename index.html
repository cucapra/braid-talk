<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">

  <title>Static Stages for Heterogeneous Programming</title>

  <link rel="stylesheet" href="node_modules/reveal.js/css/reveal.css">
  <link rel="stylesheet" href="node_modules/reveal.js/css/theme/white.css">
  <link rel="stylesheet" href="rsrc/dingus.css">
  <link rel="stylesheet" href="rsrc/codemirror.css">
  <link rel="stylesheet" href="talk.css">
  <link rel="stylesheet" href="node_modules/highlight.js/styles/github-gist.css">

  <script src="node_modules/headjs/dist/1.0.0/head.min.js"></script>
</head>
<body>
<div class="reveal">
<div class="slides">

<section data-example="webgl">
  <h3>Unified programming</h3>

  <script type="text/example" data-preamble="1">
# Load buffers and parameters for the model.
var mesh = load_obj("teapot.obj");
var indices = mesh_indices(mesh);
var size = mesh_size(mesh);

# Position the model.
var model = mat4.create();
mat4.translate(model, model, vec3(0.0, -3.0, 0.0));
mat4.scale(model, model, vec3(0.3, 0.3, 0.3));
mat4.rotateX(model, model, -1.0);

var normal = mesh_normals(mesh);
var tr = projection * view * model;
  </script>
  <script type="text/example">
# Get the geometry for the teapot.
var position = mesh_positions(mesh);

# CPU render loop stage.
render js<

  # Vertex shader stage.
  vertex glsl<
    gl_Position = tr * vec4(position, 1.0);

    # Fragment shader stage.
    fragment glsl<
      gl_FragColor = vec4(0.32, 0.63, 0.07, 1.0);
    >
  >;

  draw_mesh(indices, size);
>
  </script>
</section>
<!--
  * One program.
  * Resembles "multilingual" programming, but Braid has the same syntax and type system for CPU and GPU shaders.
  * Staging annotations indicate where and when to run the code.
-->

<section data-example="webgl">
  <h3>Specializing shaders</h3>

  <script type="text/example" data-preamble="1">
# Load buffers and parameters for the model.
var mesh = load_obj("teapot.obj");
var indices = mesh_indices(mesh);
var size = mesh_size(mesh);
var pos = mesh_positions(mesh);
var norm = mesh_normals(mesh);

# Position the model.
var model = mat4.create();
mat4.translate(model, model, vec3(0.0, -3.0, 0.0));
mat4.scale(model, model, vec3(0.3, 0.3, 0.3));
mat4.rotateX(model, model, -1.0);

# The parameters for the Phong shader.
var specular = 100.0;
var light_color = vec3(0.32, 0.63, 0.07);
var lightpos = vec3(20.0, 0.0, 20.0);

# ---

# Phong shader.
def phong(model: Mat4, matte: Float) (
  var camera_pos = eye(view);

  vertex glsl<
    gl_Position = projection * view * model * vec4(pos, 1.0);

    fragment glsl<
      # Convert to world space.
      var position_world = vec3(model * vec4(pos, 1.0));
      var normal_world = normalize(vec3(model * vec4(norm, 0.0)));
      var view_dir_world = normalize(camera_pos - position_world);

      # Light.
      var light_direction = normalize(lightpos - position_world);

      # Diffuse.
      var ndl = vec3( max(0.0, dot(normal_world, light_direction)) );

      # Specular.
      var angle = normalize(view_dir_world + light_direction);
      var spec_comp_b = max(0.0, dot(normal_world, angle));
      var spec_comp = pow( spec_comp_b, max(1.0, specular) ) * 2.0;

      var out = if (matte == 1.0) (light_color * ndl) (light_color * ndl + vec3(spec_comp));
      gl_FragColor = vec4(out, 1.0);
    >
  >;
);

# ---

# "Solid color" shader.
def solid(model: Mat4) (
  vertex glsl<
    gl_Position = projection * view * model * vec4(pos, 1.0);
    fragment glsl<
      gl_FragColor = vec4(light_color, 1.0);
    >;
  >;
);

# ---

# Different positions.
var model1 = mat4.create();
mat4.translate(model1, model, vec3(0.0, -30.0, -10.0));
var model2 = mat4.create();
mat4.translate(model2, model, vec3(0.0, 8.0, 20.0));
var model3 = mat4.create();
mat4.translate(model3, model, vec3(0.0, 0.0, 0.0));
  </script>
  <script type="text/example">
render js<
  phong(model1, 0.0);
  draw_mesh(indices, size);

  phong(model2, 1.0);
  draw_mesh(indices, size);

  solid(model3);
  draw_mesh(indices, size);
>
  </script>
</section>
<!-- Take general GPU shader code and specialize it for specific appearances.
  -->

<section data-example="interp">
  <script type="text/example">
2 * 2 * 2
  </script>
</section>

<section data-example="interp">
  <h2>Quote</h2>
  <script type="text/example">
< 2 * 2 * 2 >
  </script>
</section>

<section data-example="interp">
  <h2>Run</h2>
  <script type="text/example">
!< 2 * 2 * 2 >
  </script>
</section>

<section data-example="interp">
  <h2>Splice</h2>
  <script type="text/example">
var x = <2>;
!< [x] * 2 * 2 >
  </script>
</section>
<!-- Then remove the ! to show the code itself. -->

<section data-example="interp">
  <h2>Types for code</h2>
  <script type="text/example">
def square(x: <Int>)
  < [x] * [x] >;
square(<3>)
  </script>
</section>
<!-- Then *add* a ! to show that the code value "works." -->
<!-- Then change one to a string to show a type error. -->

<section>
  <h4>
    Multi-stage programming guarantees that
    <strong>any generated program will be well-typed.</strong>
  </h4>
</section>
<!-- TODO Semantics here? -->

<section data-example="interp">
  <h2>Communication through literals</h2>
  <script type="text/example">
var x = 2;
< [x] * 21 >
  </script>
</section>
<!-- Change 2 to <2> to show lifting. -->

<section data-example="interp">
  <h2>
    Braid&rsquo;s new construct:<br>
    Materialization
  </h2>
  <script type="text/example">
var x = 2;
< %[x] * 21 >
  </script>
</section>
<!-- Add ! to show result of executing the opaque value. -->
<!-- Perhaps show splicing being combined? -->

<section>
  <h2>Also in Braid</h2>
  <p>
    <strong>Multi-level</strong> escapes<br>
    for composing placement and specialization
  </p>
  <p>
    <strong>Open code</strong><br>
    for flexible specialization
  </p>
  <p>
  <strong>Staging-based macros</strong><br>
  for reusable specialization strategies
  </p>
  <p class="footnote">
    See the paper or <strong>braidgl.com</strong> for details.
  </p>
</section>

<section>
  <h2>
    Backend annotations<br>
    in BraidGL
  </h2>
  <p>
    <code>js&lt;...&gt;</code>: Emit JavaScript for the CPU.
  </p>
  <p>
    <code>glsl&lt;...&gt;</code>: Emit GLSL for GPU shaders.
  </p>
</section>

<section data-example="webgl">
  <script type="text/example" data-preamble="1">
# Load buffers and parameters for the model.
var mesh = load_obj("teapot.obj");
var indices = mesh_indices(mesh);
var size = mesh_size(mesh);

# Position the model.
var model = mat4.create();
mat4.translate(model, model, vec3(0.0, -3.0, 0.0));
mat4.scale(model, model, vec3(0.3, 0.3, 0.3));
mat4.rotateX(model, model, -1.0);
  </script>
  <script type="text/example">
# Get the geometry for the teapot.
var position = mesh_positions(mesh);
var normal = mesh_normals(mesh);

# Render each frame.
render js<
  var tr = projection * view * model;

  vertex glsl<
    gl_Position = tr * vec4(position, 1.0);

    fragment glsl<
      gl_FragColor = vec4(0.32, 0.63, 0.07, 1.0);
    >
  >;

  draw_mesh(indices, size);
>
  </script>
</section>
<!-- Change the colors to abs(normal). -->

<section data-example="webgl">
  <script type="text/example" data-preamble="1">
# Load buffers and parameters for the main model.
var mesh = load_obj("bunny.obj");
var pos = mesh_positions(mesh);
var norm = mesh_normals(mesh);
var indices = mesh_indices(mesh);
var size = mesh_size(mesh);

# The parameters for the Phong shader.
var specular = 100.0;
var light_color = vec3(0.32, 0.63, 0.07);
var lightpos = vec3(20.0, 0.0, 20.0);

# ---

# Phong shader.
def phong(model: Mat4, matte: Float) (
  var camera_pos = eye(view);

  vertex glsl<
    gl_Position = projection * view * model * vec4(pos, 1.0);

    fragment glsl<
      # Convert to world space.
      var position_world = vec3(model * vec4(pos, 1.0));
      var normal_world = normalize(vec3(model * vec4(norm, 0.0)));
      var view_dir_world = normalize(camera_pos - position_world);

      # Light.
      var light_direction = normalize(lightpos - position_world);

      # Diffuse.
      var ndl = vec3( max(0.0, dot(normal_world, light_direction)) );

      # Specular.
      var angle = normalize(view_dir_world + light_direction);
      var spec_comp_b = max(0.0, dot(normal_world, angle));
      var spec_comp = pow( spec_comp_b, max(1.0, specular) ) * 2.0;

      var out = if (matte == 1.0) (light_color * ndl) (light_color * ndl + vec3(spec_comp));
      gl_FragColor = vec4(out, 1.0);
    >
  >;
);

# ---

# Position the models.
var id = mat4.create();

var model1 = mat4.create();
mat4.translate(model1, model1, vec3(0.0, 0.0, 0.0));
mat4.scale(model1, model1, vec3(8.0, 8.0, 8.0));

var model2 = mat4.create();
mat4.translate(model2, model2, vec3(0.0, -12.0, 0.0));
mat4.scale(model2, model2, vec3(8.0, 8.0, 8.0));

# Rotation matrix.
var rot = mat4.create();
  </script>
  <script type="text/example">
render js<
  # Rotation.
  mat4.rotateY(rot, id, Date.now() / 1000);

  # Lighting model with specular reflection.
  phong(rot * model1, 0.0);
  draw_mesh(indices, size);

  # Without specular reflection (matte material).
  phong(rot * model2, 1.0);
  draw_mesh(indices, size);
>
  </script>
</section>
<!-- Not showing the actual shader, but there's an appearance parameter
  here... -->

<section data-example="webgl">
  <script type="text/example" data-preamble="1">
# Load buffers and parameters for the main model.
var mesh = load_obj("bunny.obj");
var pos = mesh_positions(mesh);
var norm = mesh_normals(mesh);
var indices = mesh_indices(mesh);
var size = mesh_size(mesh);

# The parameters for the Phong shader.
var specular = 100.0;
var light_color = vec3(0.32, 0.63, 0.07);
var lightpos = vec3(20.0, 0.0, 20.0);

# ---

# Phong shader.
def phong(model: Mat4, matte: Float) (
  var camera_pos = eye(view);

  vertex glsl<
    gl_Position = projection * view * model * vec4(pos, 1.0);

    fragment glsl<
      # Convert to world space.
      var position_world = vec3(model * vec4(pos, 1.0));
      var normal_world = normalize(vec3(model * vec4(norm, 0.0)));
      var view_dir_world = normalize(camera_pos - position_world);

      # Light.
      var light_direction = normalize(lightpos - position_world);

      # Diffuse.
      var ndl = vec3( max(0.0, dot(normal_world, light_direction)) );

      # Specular.
      var angle = normalize(view_dir_world + light_direction);
      var spec_comp_b = max(0.0, dot(normal_world, angle));
      var spec_comp = pow( spec_comp_b, max(1.0, specular) ) * 2.0;

      var out = if (matte == 1.0) (light_color * ndl) (light_color * ndl + vec3(spec_comp));
      gl_FragColor = vec4(out, 1.0);
    >
  >;
);

# ---

# Position the models.
var id = mat4.create();

var model1 = mat4.create();
mat4.translate(model1, model1, vec3(0.0, 0.0, 0.0));
mat4.scale(model1, model1, vec3(8.0, 8.0, 8.0));

var model2 = mat4.create();
mat4.translate(model2, model2, vec3(0.0, -12.0, 0.0));
mat4.scale(model2, model2, vec3(8.0, 8.0, 8.0));

# Rotation matrix.
var rot = mat4.create();
  </script>
  <script type="text/example">
# Compile-time stage.
var matte = 1.0;

!<
  # Run-time stage.
  render js<
    mat4.rotateY(rot, id, Date.now() / 1000);

    phong(rot * model1, matte);
    draw_mesh(indices, size);

    phong(rot * model2, matte);
    draw_mesh(indices, size);
  >
>
  </script>
</section>
<!-- We can create a "compile-time stage" by moving our computation into a
  quote and then running it. This lets us splice values into our host and
  shader code alike. -->

<section>
  <h2>
    Specializing on a compile-time parameter
  </h2>
  <p>
    <code>gl_FragColor = if matte diffuse (diffuse + ...)</code>
  </p>
  <p>
    <code>gl_FragColor = [ if matte &lt;diffuse&gt; (diffuse + ...) ]</code>
  </p>
</section>
<!-- Then, using splices, we can use the compile-time parameter to eliminate
  the spectral part of the lighting model. -->

</div>
</div>

<!-- The dingus DOM, which gets reused on all code slides. -->
<div class="sscdingus">
  <div class="input">
      <textarea class="code"></textarea>
  </div>

  <div class="arrow">
    ➡
  </div>

  <div class="output">
      <div class="error"></div>
      <div class="primary">
        <pre class="result"></pre>
        <div class="visual"></div>
        <div class="fps"></div>
      </div>
      <div class="secondary">
        <pre class="compiled"></pre>
      </div>
  </div>
</div>

<script src="node_modules/reveal.js/js/reveal.js"></script>
<script src="rsrc/ssc.bundle.js"></script>
<script src="talk.js"></script>

</body>
</html>
